import { supabase } from '@/integrations/supabase/client';
import { Tables, TablesInsert, TablesUpdate } from '@/integrations/supabase/types';

type Appointment = Tables<'appointments'>;
type AppointmentInsert = TablesInsert<'appointments'>;
type DoctorAvailability = Tables<'doctor_availability'>;
type Patient = Tables<'patients'>;

export interface AppointmentWithPatient extends Appointment {
  patient?: Pick<Patient, 'patient_id' | 'first_name' | 'last_name'>;
}

export const appointmentService = {
  async getAll(filters?: { doctorId?: string; patientId?: string; date?: string; status?: string }): Promise<AppointmentWithPatient[]> {
    let query = supabase.from('appointments').select(`
      *,
      patient:patients!appointments_patient_id_fkey(patient_id, first_name, last_name)
    `);
    
    if (filters?.doctorId) {
      query = query.eq('doctor_id', filters.doctorId);
    }
    
    if (filters?.patientId) {
      query = query.eq('patient_id', filters.patientId);
    }
    
    if (filters?.date) {
      query = query.eq('appointment_date', filters.date);
    }
    
    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    
    const { data, error } = await query
      .order('appointment_date', { ascending: true })
      .order('appointment_time', { ascending: true });
    
    if (error) throw error;
    return (data || []) as AppointmentWithPatient[];
  },

  async getById(id: string): Promise<Appointment | null> {
    const { data, error } = await supabase
      .from('appointments')
      .select('*')
      .eq('id', id)
      .maybeSingle();
    
    if (error) throw error;
    return data;
  },

  async create(data: Omit<AppointmentInsert, 'appointment_id'>): Promise<Appointment> {
    // appointment_id is auto-generated by trigger - don't pass it
    const { data: newAppointment, error } = await supabase
      .from('appointments')
      .insert(data as AppointmentInsert)
      .select()
      .single();
    
    if (error) throw error;
    return newAppointment;
  },

  async update(id: string, data: TablesUpdate<'appointments'>): Promise<Appointment | null> {
    const { data: updated, error } = await supabase
      .from('appointments')
      .update(data)
      .eq('id', id)
      .select()
      .single();
    
    if (error) throw error;
    return updated;
  },

  async cancel(id: string): Promise<boolean> {
    const { error } = await supabase
      .from('appointments')
      .update({ status: 'cancelled' })
      .eq('id', id);
    
    if (error) throw error;
    return true;
  },

  async getAvailableSlots(doctorId: string, date: string): Promise<string[]> {
    const dayOfWeek = new Date(date).getDay();
    
    // Get doctor availability for that day
    const { data: availability } = await supabase
      .from('doctor_availability')
      .select('*')
      .eq('doctor_id', doctorId)
      .eq('day_of_week', dayOfWeek)
      .eq('is_available', true)
      .maybeSingle();
    
    if (!availability) return [];
    
    // Generate 30-minute slots
    const slots: string[] = [];
    const [startHour] = availability.start_time.split(':').map(Number);
    const [endHour] = availability.end_time.split(':').map(Number);
    
    for (let hour = startHour; hour < endHour; hour++) {
      slots.push(`${String(hour).padStart(2, '0')}:00`);
      slots.push(`${String(hour).padStart(2, '0')}:30`);
    }
    
    // Get booked appointments for that date
    const { data: bookedAppointments } = await supabase
      .from('appointments')
      .select('appointment_time')
      .eq('doctor_id', doctorId)
      .eq('appointment_date', date)
      .neq('status', 'cancelled');
    
    const bookedSlots = bookedAppointments?.map(a => a.appointment_time.substring(0, 5)) || [];
    
    return slots.filter(s => !bookedSlots.includes(s));
  },

  async getDoctorAvailability(doctorId: string): Promise<DoctorAvailability[]> {
    const { data, error } = await supabase
      .from('doctor_availability')
      .select('*')
      .eq('doctor_id', doctorId);
    
    if (error) throw error;
    return data || [];
  },

  async updateDoctorAvailability(doctorId: string, items: Partial<DoctorAvailability>[]): Promise<DoctorAvailability[]> {
    // Delete existing availability for this doctor
    await supabase
      .from('doctor_availability')
      .delete()
      .eq('doctor_id', doctorId);
    
    // Insert new availability
    const inserts = items.map(item => ({
      doctor_id: doctorId,
      day_of_week: item.day_of_week!,
      start_time: item.start_time || '09:00',
      end_time: item.end_time || '17:00',
      is_available: item.is_available ?? true,
    }));
    
    const { data, error } = await supabase
      .from('doctor_availability')
      .insert(inserts)
      .select();
    
    if (error) throw error;
    return data || [];
  },
};
